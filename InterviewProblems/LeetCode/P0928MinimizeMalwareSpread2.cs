using System;
using System.Linq;

namespace InterviewProblems.LeetCode
{
    public class P0928MinimizeMalwareSpread2 : ITestable
    {
        public void RunTest()
        {
            foreach (var (graph, initial) in new (int[][], int[])[]
            {
                (new[]
                {
                    new[] { 1,0,0,0,0,0,0,0,1 },
                    new[] {0,1,0,1,0,0,0,0,0 },
                    new[] { 0,0,1,1,0,1,0,0,0 },
                    new[] { 0,1,1,1,1,0,1,0,0 },
                    new[]{ 0,0,0,1,1,1,0,0,0 },
                    new[]{ 0,0,1,0,1,1,0,0,0 },
                    new[]{ 0,0,0,1,0,0,1,1,0 },
                    new[]{ 0,0,0,0,0,0,1,1,1 },
                    new[]{ 1,0,0,0,0,0,0,1,1 },
                }, new[]{3,7}),
                //(new[] { new[] {1,1,0}, new[] {1,1,0}, new[] {0,0,1} }, new[]{0,1}),
                //(new[] { new[] {1,1,0}, new[] {1,1,1}, new[] {0,1,1} }, new[]{0,1}),
                //(new[]
                //{
                //    new[] { 1, 0, 0, 0, 0, 0, 0, 0, 0 },
                //    new[] {0,1,0,0,0,0,0,0,1 },
                //    new[] { 0, 0, 1, 0, 0, 0, 0, 0, 0 },
                //    new[] { 0,0,0,1,0,0,0,0,1 },
                //    new[]{ 0, 0, 0, 0, 1, 0, 1, 1, 1 },
                //    new[]{ 0, 0, 0, 0, 0, 1, 0, 0, 1 },
                //    new[]{ 0, 0, 0, 0, 1, 0, 1, 1, 0 },
                //    new[]{ 0, 0, 0, 0, 1, 0, 1, 1, 0 },
                //    new[]{ 0, 1, 0, 1, 1, 1, 0, 0, 1 }
                //}, new[]{8,4,2,0}),
            })
            {
                //Console.WriteLine(MinMalwareSpreadDfs(graph, initial));
                Console.WriteLine(MinMalwareSpreadUnionFind(graph, initial));
            }
        }

        public int MinMalwareSpreadDfs(int[][] graph, int[] initial)
        {
            var n = graph.Length;

            for (var i = 0; i < n; ++i)
            {
                graph[i][i] = -1;
            }

            for (var i = 0; i < initial.Length; ++i)
            {
                var idx = initial[i];
                graph[idx][idx] = -2;
            }

            var resultNode = n;
            var resultCount = int.MinValue;

            foreach (var mw in initial)
            {
                var currCount = 0;
                for (var i = 0; i < n; ++i)
                {
                    if (mw != i && graph[mw][i] == 1 && graph[i][i] == -1) currCount += Dfs(mw, i);
                }

                if (currCount > resultCount || (currCount == resultCount && mw < resultNode))
                {
                    resultNode = mw;
                    resultCount = currCount;
                }
            }

            return resultNode;

            int Dfs(int init, int x)
            {
                if (graph[x][x] == -2) return 0;

                //if (graph[x][x] > -1 && graph[x][x] != init) return 0;

                graph[x][x] = init;
                var count = 1;

                foreach (var child in Enumerable.Range(0, n).Where(i => x != i && i != init && graph[x][i] == 1 && graph[i][i] != init))
                {
                    if (graph[child][child] == init) continue;
                    var c = Dfs(init, child);
                    if (c == 0)
                    {
                        graph[x][x] = -2;
                        return 0;
                    }

                    count += c;
                }

                return count;
            }
        }

        public int MinMalwareSpreadUnionFind(int[][] graph, int[] initial)
        {
            var n = graph.Length;

            for (var i = 0; i < initial.Length; ++i)
            {
                graph[initial[i]][initial[i]] = 2;
            }

            var ds = new DisjointSet(n);
            for (var i = 0; i < n; ++i)
            {
                if (graph[i][i] == 2) continue;

                for (var j = 0; j < n; ++j)
                {
                    if (i == j || graph[j][j] == 2 || graph[i][j] == 0) continue;
                    ds.Union(i, j);
                }
            }

            var infectedBy = Enumerable.Repeat(-1, n).ToArray();
            for (var i = 0; i < n; ++i)
            {
                if (graph[i][i] != 2)
                {
                    continue;
                }

                for (var j = 0; j < n; ++j)
                {
                    if (i == j || graph[j][j] == 2 || graph[i][j] == 0)
                    {
                        continue;
                    }

                    var component = ds.Find(j);
                    if (infectedBy[component] == i)
                    {
                        continue;
                    }

                    if (infectedBy[component] == -2 || infectedBy[component] >= 0)
                    {
                        infectedBy[component] = -2;
                        continue;
                    }

                    infectedBy[component] = i;
                }
            }

            var resultCount = 0;
            var resultNode = n;
            for (var i = 0; i < n; ++i)
            {
                if (graph[i][i] == 2 || infectedBy[i] < 0)
                {
                    continue;
                }

                var mw = infectedBy[i];
                infectedBy[mw] = infectedBy[mw] == -1 ? ds.Size(i) : infectedBy[mw] + ds.Size(i);

                if (infectedBy[mw] > resultCount || (infectedBy[mw] == resultCount && mw < resultNode))
                {
                    resultCount = infectedBy[mw];
                    resultNode = mw;
                }
            }

            return resultNode;
        }

        class DisjointSet
        {
            private readonly int[] _parent;
            private readonly int[] _size;

            public DisjointSet(int c)
            {
                _parent = Enumerable.Range(0, c).ToArray();
                _size = Enumerable.Repeat(1, c).ToArray();
            }

            public int Find(int node)
            {
                if (node == _parent[node]) return node;

                _parent[node] = Find(_parent[node]);

                return _parent[node];
            }

            public void Union(int node1, int node2)
            {
                var p1 = Find(node1);
                var p2 = Find(node2);

                if (p1 == p2) return;

                if (_size[p1] >= _size[p2])
                {
                    _size[p1] += _size[p2];
                    _parent[p2] = p1;
                }
                else
                {
                    _size[p2] += _size[p1];
                    _parent[p1] = p2;
                }
            }

            public int Size(int node)
            {
                return _size[Find(node)];
            }
        }
    }
}
